/** * Advanced Lazy Loading with Intersection Observer API * Provides smooth image loading with blur-up effect and performance optimization */(function() {    'use strict';    // Check if Intersection Observer is supported    if (!('IntersectionObserver' in window)) {        console.warn('Intersection Observer not supported, using fallback');        loadAllImages();        return;    }    // Configuration    const config = {        rootMargin: '50px', // Start loading 50px before image enters viewport        threshold: 0.01    };    // Create Intersection Observer    const imageObserver = new IntersectionObserver((entries, observer) => {        entries.forEach(entry => {            if (entry.isIntersecting) {                const img = entry.target;                loadImage(img);                observer.unobserve(img);            }        });    }, config);    /**     * Load image with fade-in effect     */    function loadImage(img) {        // Skip if already loading or loaded        if (img.dataset.loading === 'true' || img.dataset.loaded === 'true') {            return;        }        img.dataset.loading = 'true';        // Get the actual image source        const src = img.dataset.src || img.src;        const srcset = img.dataset.srcset;        // Create a new image to preload        const tempImg = new Image();        tempImg.onload = function() {            // Update the actual image            img.src = src;            if (srcset) {                img.srcset = srcset;            }            // Add loaded class for CSS animation            img.classList.add('lazy-loaded');            img.dataset.loaded = 'true';            img.dataset.loading = 'false';            // Trigger any callbacks            img.dispatchEvent(new CustomEvent('lazyloaded'));        };        tempImg.onerror = function() {            console.error('Failed to load image:', src);            img.data.loading = 'false';        };        // Start loading        tempImg.src = src;        if (srcset) {            tempImg.srcset = srcset;        }    }    /**     * Fallback for browsers without Intersection Observer     */    function loadAllImages() {        const images = document.querySelectorAll('img[loading="lazy"]');        images.forEach(img => {            img.removeAttribute('loading');            loadImage(img);        });    }    /**     * Initialize lazy loading     */    function init() {        // Get all lazy images        const lazyImages = document.querySelectorAll('img[loading="lazy"]');        if (lazyImages.length === 0) {            return;        }        // Observe each image        lazyImages.forEach(img => {            // Add loading state            img.dataset.loading = 'false';            img.dataset.loaded = 'false';            // Store original src if using data-src            if (img.dataset.src) {                // Image is already set up with data-src                imageObserver.observe(img);            } else if (img.src && img.src !== '') {                // Image has src, observe it for lazy loading                imageObserver.observe(img);            }        });    }    /**     * Handle dynamic content (images added after page load)     */    function observeNewImages() {        const observer = new MutationObserver((mutations) => {            mutations.forEach((mutation) => {                if (mutation.addedNodes.length) {                    mutation.addedNodes.forEach((node) => {                        if (node.nodeType === 1) { // Element node                            const newImages = node.querySelectorAll('img[loading="lazy"]');                            newImages.forEach(img => {                                img.dataset.loading = 'false';                                img.dataset.loaded = 'false';                                imageObserver.observe(img);                            });                        }                    });                }            });        });        observer.observe(document.body, {            childList: true,            subtree: true        });    }    // Initialize when DOM is ready    if (document.readyState === 'loading') {        document.addEventListener('DOMContentLoaded', init);    } else {        init();    }    // Observe for dynamically added images    observeNewImages();    // Expose API for manual control    window.LazyLoad = {        init: init,        loadImage: loadImage,        loadAll: loadAllImages    };})();